<!-- Graphics Example Code.  index.html - The web page document containing the canvas (drawing surface), that launches your javascript files.  By Garett //-->
<!DOCTYPE html> <html> <head> <meta charset="UTF-8"/> <link rel="icon" href="assets/fav.ico">
    <script type="text/javascript" src="tinywebgl-ucla.js" ></script>  <!--  Javascript "include" files.  Any code in them gets executed as part of the page loading. //-->
    <script type="text/javascript" src="dependencies.js"   ></script>
    <script type="text/javascript"> "use strict"
    var                    numToColor = {};

    window.onload = function init()        // ********************* THE ENTRY POINT OF THE WHOLE PROGRAM STARTS HERE *********************
    { window.contexts = {};                                                            // A global variable, "contexts".  Browsers support up to 16 WebGL contexts per page.

    const scenes  = ["Tutorial_Animation", "Movement_Controls", "Global_Info_Table" ]; // Register some scenes to the "Canvas_Manager" object -- which WebGL calls
    // upon every time a draw / keyboard / mouse event happens.

    if( eval( "typeof " + scenes[0] ) !== "undefined" )
    { document.getElementById( "canvases" ).appendChild( Object.assign( document.createElement( "canvas" ), { id: "main_canvas", width: 800, height: 600 } ) );
    contexts[ "main_canvas" ] = new Canvas_Manager( "main_canvas", Color.of( 0,0,0,1 ), scenes );   // Manage the WebGL canvas.  Second parameter sets background color.
    for( let c in contexts ) contexts[ c ].render();     // Call render() for each WebGL context on this page.  Then render() will re-queue itself for more calls.

    Code_Manager.display_code( eval( scenes[0] ) );                                  // Display the code for our demo on the page, starting with the first scene in the list.
    for( let list of [ core_dependencies, all_dependencies ] )
    document.querySelector( "#class_list" ).rows[2].appendChild( Object.assign( document.createElement( "td" ), {
        innerHTML: list.reduce( (acc, x) => acc += "<a href='javascript:void(0);' onclick='Code_Manager.display_code(" + x + ")'>" + x + "</a><br>", "" ) } ) );
        document.getElementsByName( "main_demo_link" )[0].innerHTML = "<a href='javascript:void(0);' onclick='Code_Manager.display_code(" + scenes[0] + ")'>" + scenes[0] + "</a><br>";
        document.querySelector("#code_display").innerHTML = "Below is the code for the demo that's running:<br>&nbsp;<br>" + document.querySelector("#code_display").innerHTML;
    }

    document.querySelector("#edit_button").addEventListener('click', () => {
        code_panel.style.display=class_list.style.display='none'; new_demo_source_code.style.display='block';
        document.getElementsByName( 'new_demo_code' )[0].value=code_display.dataset.displayed.toString() } )
        const form = document.forms.namedItem("new_demo_source_code");
        form.addEventListener('submit', function(event)
        { if( document.getElementsByName( "finished" )[0].checked )
        alert( "Your demo will be submitted.  If approved, you will start being asked for a password to make any further updates to it.  This password "
        + "will appear right now, below the submit button, and then (assuming submission worked) it will never appear again.  Write it down." );
        var xhr = new XMLHttpRequest();
        xhr.open("POST", "/submit-demo?Unapproved", true);
        xhr.responseType = "json";
        xhr.onload = function(event)
        { if (xhr.status != 200) { document.querySelector("#submit_result").textContent = "Error " + xhr.status + " when trying to upload."; return }
        document.querySelector("#submit_result").textContent = this.response.message;
        // if( this.response.hide_finished_checkbox ) { document.getElementsByName( "finished" )[0].checked = false; expert_panel.style.display = "none" }
        if( this.response.show_password  ) document.getElementsByName( "password" )[0] .style.display = "inline";
        if( this.response.show_overwrite ) document.querySelector( "#overwrite_panel" ).style.display = "inline";
    };
    xhr.setRequestHeader("Content-Type", "application/json");
    xhr.send( JSON.stringify( Array.from( form.elements ).reduce( ( accum, elem ) =>
    { if( elem.value && !( ['checkbox', 'radio'].includes(elem.type) && !elem.checked ) ) accum[elem.name] = elem.value; return accum }, {} ) ) );
    event.preventDefault();
}, false);
}

// Below is the demo you will see when you run the program!

class Tutorial_Animation extends Scene_Component  // An example of a Scene_Component that our class Canvas_Manager can manage.  Like most, this one draws 3D shapes.
{ constructor( context )
    { super( context );

        let square_array = Vec.cast( [ 1,0,-1 ], [ 0,1,-1 ], [ -1,0,-1 ], [ 0,-1,-1 ], [ 1,0,-1 ] ),               // Some helper arrays of points located along
        star_array = Array(19).fill( Vec.of( 1,0,-1 ) ), circle_array = Array(40).fill( Vec.of( 1,0,-1 ) );  // curves.  We'll extrude these into surfaces.
        circle_array = circle_array.map( (x,i,a) => Mat4.rotation( i/(a.length-1) * 2*Math.PI, Vec.of( 0,0,1 ) ).times( x.to4(1) ).to3() );
        star_array   =   star_array.map( (x,i,a) => Mat4.rotation( i/(a.length-1) * 2*Math.PI, Vec.of( 0,0,1 ) ).times( Mat4.translation([ (i%2)/2,0,0 ]) ).times( x.to4(1) ).to3() );

        let sin_rows_func       =      i  => { return Vec.of( .5 + Math.sin(777*i)/4, 2-4*i, 0 ) },                                   // Different callbacks for telling Grid_Patch
        sin_columns_func    = ( j,p ) => { return Mat4.translation([ Math.sin(777*j)/4,0,4/30    ]).times( p.to4(1) ).to3() },    // how it chould advance to the next row/column.
        rotate_columns_func = ( j,p ) => { return Mat4.rotation( .1*j*Math.PI, Vec.of( 0,1,0 )    ).times( p.to4(1) ).to3() },
        sample_square_func  =      i  => { return Grid_Patch.sample_array( square_array, i ) },
        sample_star_func    =      i  => { return Grid_Patch.sample_array( star_array,   i ) },
        sample_circle_func  =      i  => { return Grid_Patch.sample_array( circle_array, i ) },
        sample_two_arrays   = (j,p,i) => { return Mat4.translation([0,0,2*j]).times( sample_star_func(i).mix( sample_circle_func(i), j ).to4(1) ).to3() },
        sample_two_arrays2  = (j,p,i) => { return Mat4.rotation( .5*j*Math.PI, Vec.of( 1,1,1 ) ).times(
            Mat4.translation([0,0,2*j]).times( sample_star_func(i).mix( sample_square_func(i), j ).to4(1) ) ).to3() },
            line_rows_func      = ( i,p ) => { return p ? Mat4.translation([0,i/50,0]).times( p.to4(1) ).to3() :  Vec.of( .01,-.05,-.1 ) },
            transform_cols_func = (j,p,i) => { return Mat4.rotation( Math.PI/8, Vec.of( 0,0,1 ) ).times( Mat4.scale([ 1.1,1.1,1.1 ])).times( Mat4.translation([ 0,0,.005 ]))
                .times( p.to4(1) ).to3() };

                var shapes = {
                    'triangle'        : new Triangle(),                            // At the beginning of our program, instantiate all shapes we plan to use,
                    'strip'             : new Square(),                              // each with only one instance in the graphics card's memory.
                    'bad_tetrahedron'   : new Tetrahedron( false ),                  // For example we would only create one "cube" blueprint in the GPU, but then
                    'tetrahedron'       : new Tetrahedron( true ),                   // re-use it many times per call to display to get multiple cubes in the scene.
                    'myshape'           : new MyShape( false ),
                    'windmill'          : new Windmill( 10 ),
                    'box'               : new Cube(),
                    'ball'              : new Subdivision_Sphere(4),
                    'wing'              : new Cube(),
                    'ghost'             : new Grid_Patch( 36, 10, sample_star_func, sample_two_arrays,  [[0,1],[0,1]] ),
                    'vase'        : new Grid_Patch( 30, 30, sin_rows_func, rotate_columns_func,   [[0,1],[0,1]] ),
                    'shell'       : new Grid_Patch( 10, 40, line_rows_func, transform_cols_func,  [[0,5],[0,1]] ),
                    'waves'      : new Grid_Patch( 30, 30, sin_rows_func, sin_columns_func,      [[0,1],[0,1]] ),
                    'shell2'     : new Grid_Patch( 30, 30, sample_star_func, sample_two_arrays2, [[0,1],[0,1]] ),
                    'tube'        : new Cylindrical_Tube  ( 10, 10, [[0,1],[0,1]] ),
                    'open_cone'   : new Cone_Tip          (  3, 10, [[0,1],[0,1]] ),
                    'donut'       : new Torus             ( 15, 15 ),
                    'gem2'        : new ( Torus             .prototype.make_flat_shaded_version() )( 20, 20 ),
                    'bad_sphere'  : new Grid_Sphere       ( 10, 10 ),                                            // A sphere made of rows and columns, with singularities
                    'septagon'    : new Regular_2D_Polygon(  2,  7 ),
                    'cone'        : new Closed_Cone       ( 4, 20, [[0,1],[0,1]] ),                       // Cone.  Useful.
                    'capped'      : new Capped_Cylinder   ( 4, 12, [[0,1],[0,1]] ),                       // Cylinder.  Also useful.
                    'axis'        : new Axis_Arrows(),                                                    // Axis.  Draw them often to check your current basis.
                    'prism'       : new ( Capped_Cylinder   .prototype.make_flat_shaded_version() )( 10, 10, [[0,1],[0,1]] ),
                    'gem'         : new ( Subdivision_Sphere.prototype.make_flat_shaded_version() )(  2     ),
                    'swept_curve' : new Surface_Of_Revolution( 10, 10, [ ...Vec.cast( [2, 0, -1], [1, 0, 0], [1, 0, 1], [0, 0, 2] ) ], [ [ 0, 1 ], [ 0, 7 ] ], Math.PI/3 ),

                };
                this.submit_shapes( context, shapes );


                //BUTTER FLY
                this.butterfly_body_length = 4;
                this.butterfly_body_height = 1;
                this.butterfly_body_width = 1;
                this.head_all = 1.5;
                this.wing_height = .2;
                // BUTTERFLY END

                this.time_offset = 0;

                this.head_size = 2;

                this.body_height = 3;
                this.body_length = 2;
                this.body_width = 1;

                this.leg_width = 1;
                this.leg_height = 2;
                this.leg_length = 1;

                this.arm_width = .5;
                this.arm_height = 2;
                this.arm_length = .5;

                this.board_width = 4;
                this.board_height = .5;
                this.board_length = 1.5;

                this.shoe_width = 1;
                this.shoe_height = .75;
                this.shoe_length = 2;

                this.cliff_width = 40;
                this.cliff_height = 50
                this.cliff_length = 40;

                this.portal_width = 40;
                this.portal_height = 60;
                this.portal_length = 7;

                this.cliff_transform = Mat4.identity();
                this.body_transform = Mat4.identity();
                this.board_transform = Mat4.identity();
                this.head_transform = Mat4.identity();
                this.branch_transform = Mat4.identity();
                this.butterfly_transform = Mat4.identity();
                this.portal_transform = Mat4.identity();
                this.genie_transform = Mat4.identity();

                this.body_transform_next = Mat4.identity();
                this.body_transform_curr = Mat4.identity();
                this.board_transform_curr = Mat4.identity();
                this.board_transform_next = Mat4.identity();
                this.butterfly_transform_curr = Mat4.identity();
                this.butterfly_transform_next = Mat4.identity();
                this.branch_transform_curr = Mat4.identity();
                this.branch_transform_next = Mat4.identity();
                this.portal_transform_curr = Mat4.identity();
                this.portal_transform_next = Mat4.identity();
                this.genie_transform_curr = Mat4.identity();
                this.genie_transform_next = Mat4.identity();

                // Place the camera, which is stored in a scratchpad for globals.  Secondly, setup the projection:  The matrix that determines how depth is treated.  It projects 3D points onto a plane.
                Object.assign( context.globals.graphics_state, { camera_transform: Mat4.translation([ 0, 0,-25 ]), projection_transform: Mat4.perspective( Math.PI/4, context.width/context.height, .1, 1000 ) } );

                // *** Materials: *** Declare new ones as temps when needed; they're just cheap wrappers for some numbers.  1st parameter:  Color (4 floats in RGBA format),
                // 2nd: Ambient light, 3rd: Diffuse reflectivity, 4th: Specular reflectivity, 5th: Smoothness exponent, 6th: Optional texture object, leave off for un-textured.
                Object.assign( this, { purplePlastic: context.get_instance( Phong_Model  ).material( Color.of( .9,.5,.9, 1 ), .4, .4, .8, 40 ),
                    greyPlastic  : context.get_instance( Phong_Model  ).material( Color.of( .5,.5,.5, 1 ), .4, .8, .4, 20 ),   // Smaller exponent means
                    blueGlass    : context.get_instance( Phong_Model  ).material( Color.of( .5,.5, 1,.2 ), .4, .8, .4, 40 ),   // a bigger shiny spot.
                    greenGrass    : context.get_instance( Phong_Model  ).material( Color.of( .5,1,.5,.2 ), .4, .8, .4, 40 ),   // a bigger shiny spot.
                    yellow: context.get_instance( Phong_Model ).material( Color.of( .8, .8, .3,  1 ), .2, 1, .7, 40 ),  // Call material() on the Phong_Shader,
                    brown:  context.get_instance( Phong_Model ).material( Color.of( .3, .3, .1,  1 ), .2, 1,  1, 40 ),  // which returns a special-made "material"
                    red:    context.get_instance( Phong_Model ).material( Color.of(  1,  0,  0, .9 ), .1, .7, 1, 40 ),  // (a JavaScript object)
                    green:  context.get_instance( Phong_Model ).material( Color.of(  0, .5,  0,  1 ), .1, .7, 1, 40 ),
                    blue:   context.get_instance( Phong_Model ).material( Color.of(  0,  0,  1, .8 ), .1, .7, 1, 40 ),
                    silver: context.get_instance( Phong_Model ).material( Color.of( .8, .8, .8,  1 ),  0,  1, 1, 40 ),
                    fire         : context.get_instance( Funny_Shader ).material(),
                    stars        : context.get_instance( Phong_Model  ).material( Color.of( 0,0,1,1 ), .5, .5, .5, 40, context.get_instance( "assets/stars.png" ) ),
                    rgb        : context.get_instance( Phong_Model  ).material( Color.of( 0,0,1,1 ), .5, .5, .5, 40, context.get_instance( "assets/rgb.jpg" ) ) } );

                    numToColor[0] = this.yellow;
                    numToColor[1] = this.brown;
                    numToColor[2] = this.red;
                    numToColor[3] = this.green;
                    numToColor[4] = this.blue;
                    numToColor[5] = this.silver;
                }

                ////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////// CUSTOM SHAPE //////////////////////////////////////
                ////////////////////////////////////////////////////////////////////////////


                ////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////// BUTTERFLY CODE //////////////////////////////////////
                ////////////////////////////////////////////////////////////////////////////
                draw_arm( graphics_state, model_transform ){ const arm = model_transform.times( Mat4.translation([ 0,0,3+1 ]) );
                    this.shapes.ball.draw( graphics_state, arm, this.blue );
                }
                draw_butterfly_head( graphics_state, model_transform ){ let head = model_transform.times( Mat4.translation([ 0,0,this.butterfly_body_length+this.head_all ]) );
                    head = head.times(Mat4.scale(Vec.of(this.head_all,this.head_all,this.head_all)));
                    this.shapes.ball.draw( graphics_state, head, this.red );
                }
                draw_abdomen( graphics_state, model_transform ){ const thorax = model_transform.times( Mat4.translation([ 0,0,3 ]) );
                    this.shapes.ball.draw( graphics_state, thorax, this.yellow );
                }
                draw_wing( graphics_state, wing_transform){
                    let wing_width = 2*Math.sqrt(2);
                    let wing_height = .2;
                    let wing_length = 2*Math.sqrt(2);
                    let hinge_width = -wing_width-1.2;
                    let hinge_height = -wing_height;
                    let hinge_length = 0;

                    //FLAPPING
                    wing_transform = wing_transform.times(Mat4.translation(Vec.of(hinge_width, hinge_height, hinge_length)));
                    wing_transform = wing_transform.times(Mat4.rotation(Math.sin(this.t*8)+.5, Vec.of(0,0,1)));
                    wing_transform = wing_transform.times(Mat4.translation(Vec.of(-hinge_width, -hinge_height, -hinge_length)));

                    //ROTATE TO DIAMOND
                    wing_transform = wing_transform.times(Mat4.rotation(Math.PI/4, Vec.of(0,1,0)));

                    //SCALE
                    wing_transform = wing_transform.times(Mat4.scale(Vec.of(wing_width, wing_height, wing_length)));
                    this.shapes.wing.draw( graphics_state, wing_transform, this.blue );
                }
                draw_leg(graphics_state, leg_transform){
                    let leg_width = this.butterfly_body_width/4;
                    let leg_height = this.butterfly_body_height;
                    let leg_length = this.butterfly_body_length/16;
                    let hinge_width = -leg_height/4;
                    let hinge_height = leg_height;
                    let hinge_length = 0;

                    //TOP LEGS
                    // FLAPPING
                    leg_transform = leg_transform.times(Mat4.translation(Vec.of(hinge_width, hinge_height, hinge_length)));
                    leg_transform = leg_transform.times(Mat4.rotation(-1 + Math.PI/4*(Math.sin(this.t*10)), Vec.of(0,0,-1)));
                    leg_transform = leg_transform.times(Mat4.translation(Vec.of(-hinge_width, -hinge_height, -hinge_length)));

                    //SCALING and drawing
                    this.shapes.box.draw(graphics_state, leg_transform.times(Mat4.scale(Vec.of(leg_width,leg_height,leg_length))),this.silver);

                    //BOTTOM LEGS
                    //offset to correct location
                    let bottom_leg = leg_transform;
                    bottom_leg = bottom_leg.times(Mat4.translation(Vec.of(0,-2*leg_height,0)));

                    //FLAPPING
                    bottom_leg = bottom_leg.times(Mat4.translation(Vec.of(hinge_width,hinge_height,hinge_length)));
                    bottom_leg = bottom_leg.times(Mat4.rotation(-1 * (Math.PI/4*(Math.sin(this.t*10)-1)), Vec.of(0,0,-1)));
                    bottom_leg = bottom_leg.times(Mat4.translation(Vec.of(-hinge_width,-hinge_height,-hinge_length)));

                    //SCALING and drawing
                    bottom_leg = bottom_leg.times(Mat4.scale(Vec.of(leg_width,leg_height,leg_length)));
                    this.shapes.box.draw(graphics_state, bottom_leg,this.blue);
                }
                draw_antennae(graphics_state, antennae_transform){
                    let ant_width = .125;
                    let ant_height = .125;
                    let ant_length = .15;
                    let hinge_width = 0;
                    let hinge_height = -ant_height;
                    let hinge_length = -ant_length;

                    //EACH ANTENNAE
                    let orig = antennae_transform;
                    for(let i of [-1, 1]) {
                        //correct location on ball
                        antennae_transform = antennae_transform.times(Mat4.rotation(-1*Math.PI/4, Vec.of(1, 0, 0)));
                        antennae_transform = antennae_transform.times(Mat4.rotation(i*Math.PI/4, Vec.of(0, 1, 0)));

                        //correct offset
                        antennae_transform = antennae_transform.times(Mat4.translation(Vec.of(0,0,this.head_all + ant_length)));
                        this.shapes.box.draw(graphics_state, antennae_transform.times(Mat4.scale(Vec.of(ant_width,ant_height,ant_length))), this.silver);

                        // small boxes
                        let j = 0;
                        while (j < 8) {
                            antennae_transform = antennae_transform.times(Mat4.translation(Vec.of(0,0,2*ant_length)));
                            antennae_transform = antennae_transform.times(Mat4.translation(Vec.of(hinge_width, hinge_height, hinge_length)));
                            antennae_transform = antennae_transform.times(Mat4.rotation(-Math.PI/24*(Math.sin(this.t*10)-1), Vec.of(1, 0, 0)));
                            antennae_transform = antennae_transform.times(Mat4.translation(Vec.of(-hinge_width, -hinge_height,-hinge_length)));
                            this.shapes.box.draw(graphics_state, antennae_transform.times(Mat4.scale([ant_width, ant_height, ant_length])), this.silver);
                            j++;
                        }

                        //BALL AT THE END
                        antennae_transform = antennae_transform.times(Mat4.translation(Vec.of(0,0,2*ant_length)));
                        antennae_transform = antennae_transform.times(Mat4.translation(Vec.of(hinge_width, hinge_height,hinge_length)));
                        antennae_transform = antennae_transform.times(Mat4.rotation(-Math.PI/24*(Math.sin(this.t*10)-1), Vec.of(1, 0, 0)));
                        antennae_transform = antennae_transform.times(Mat4.translation(Vec.of(-hinge_width, -hinge_height,-hinge_length)));
                        this.shapes.ball.draw(graphics_state, antennae_transform.times(Mat4.scale([.2, .2, .2])), this.yellow);
                        antennae_transform = orig;
                    }
                }
                draw_butterfly(graphics_state, model_transform, scene){
                    //HOVERING
                    // model_transform = model_transform.times( Mat4.translation( Vec.of( 0,10,0 ) ) ); // Move butterfly to air
                    if (!this.hover) {
                        // model_transform = model_transform.times(Mat4.rotation(this.t * 2, Vec.of(0, 1, 0)));
                        model_transform = model_transform.times(Mat4.translation([0, 0, Math.sin(10 * this.t * Math.PI / 4)]));
                    }
                    model_transform = model_transform.times(Mat4.translation(Vec.of(0, 0, 10)));
                    model_transform = model_transform.times(Mat4.rotation(Math.PI/2, Vec.of(-1, 4, 0)));

                    // //WING TRANSFORM
                    let wing_transform = model_transform.times(Mat4.translation(Vec.of(2,0,0)));
                    let reflect_wing = wing_transform.times(Mat4.scale(Vec.of(-1,1,1))).times(Mat4.translation(Vec.of(4,0,0)));
                    //    this.draw_wing(graphics_state, wing_transform);
                    this.draw_wing(graphics_state, wing_transform.times(Mat4.translation(Vec.of(3,this.butterfly_body_height+this.wing_height,this.butterfly_body_length))));
                    this.draw_wing(graphics_state, wing_transform.times(Mat4.translation(Vec.of(3,this.butterfly_body_height+this.wing_height,-this.butterfly_body_length))));
                    this.draw_wing(graphics_state, reflect_wing.times(Mat4.translation(Vec.of(3,this.butterfly_body_height+this.wing_height,this.butterfly_body_length))));
                    this.draw_wing(graphics_state, reflect_wing.times(Mat4.translation(Vec.of(3,this.butterfly_body_height+this.wing_height,-this.butterfly_body_length))));

                    //LEG
                    let leg_transform = model_transform;
                    let reflect_leg = leg_transform.times(Mat4.scale(Vec.of(-1,1,1)));
                    this.draw_leg(graphics_state, leg_transform.times(Mat4.translation(Vec.of(5*this.butterfly_body_width/4,-2*this.butterfly_body_height,15*this.butterfly_body_length/16))));
                    this.draw_leg(graphics_state, leg_transform.times(Mat4.translation(Vec.of(5*this.butterfly_body_width/4,-2*this.butterfly_body_height,9*this.butterfly_body_length/16))));
                    this.draw_leg(graphics_state, leg_transform.times(Mat4.translation(Vec.of(5*this.butterfly_body_width/4,-2*this.butterfly_body_height,4*this.butterfly_body_length/16))));
                    this.draw_leg(graphics_state, reflect_leg.times(Mat4.translation(Vec.of(5*this.butterfly_body_width/4,-2*this.butterfly_body_height,15*this.butterfly_body_length/16))));
                    this.draw_leg(graphics_state, reflect_leg.times(Mat4.translation(Vec.of(5*this.butterfly_body_width/4,-2*this.butterfly_body_height,9*this.butterfly_body_length/16))));
                    this.draw_leg(graphics_state, reflect_leg.times(Mat4.translation(Vec.of(5*this.butterfly_body_width/4,-2*this.butterfly_body_height,4*this.butterfly_body_length/16))));

                    //THORAX
                    this.shapes.box.draw( graphics_state, model_transform.times( Mat4.scale([ this.butterfly_body_width,this.butterfly_body_height,this.butterfly_body_length ]) ), this.yellow ); // width = 1, height = 1, length = 3

                    //HEAD
                    this.draw_butterfly_head( graphics_state, model_transform.times( Mat4.scale([ 1,1,1 ]) ) );

                    //ANTENNAE
                    let antennae_transform = model_transform.times(Mat4.scale([1,1,1])).times( Mat4.translation([ 0,0,this.butterfly_body_length+this.head_all ]) );
                    this.draw_antennae(graphics_state, antennae_transform);

                    //ABDOMEN
                    this.draw_abdomen(graphics_state, model_transform.times( Mat4.scale([ 1,1, -2]) ));
                }
                ////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////// BUTTERFLY ENDS //////////////////////////////////////
                ////////////////////////////////////////////////////////////////////////////

                draw_head (graphics_state, head_transform, scene) {
                    head_transform = head_transform.times( Mat4.translation([ 0, 5, 0 ]) );
                    this.shapes.ball.draw(graphics_state, head_transform.times(Mat4.scale(Vec.of(this.head_size,this.head_size,this.head_size))), this.greyPlastic);
                }
                draw_arms (graphics_state, arm_transform, scene) {
                    let hinge_width = this.arm_width;
                    let hinge_height = this.arm_height;
                    let hinge_length = 0;


                    var upper_arm_transform = arm_transform;
                    var orig = upper_arm_transform;
                    for (let i of [-1,1]) {
                        //correct location
                        upper_arm_transform = upper_arm_transform.times(Mat4.translation([-1.25*this.body_length*i,this.body_height/3,0])); //transfer to hinge

                        //hinge location
                        upper_arm_transform = upper_arm_transform.times(Mat4.translation(Vec.of(hinge_width*i, hinge_height, hinge_length)));
                        upper_arm_transform = upper_arm_transform.times(Mat4.rotation(-1 + Math.PI/12*(Math.sin(this.globals.graphics_state.animation_time/100)), Vec.of(0,0,1*i)));
                        upper_arm_transform = upper_arm_transform.times(Mat4.translation(Vec.of(-hinge_width*i, -hinge_height, -hinge_length)));

                        //scaling
                        upper_arm_transform = upper_arm_transform.times(Mat4.scale(Vec.of(this.arm_width,this.arm_height,this.arm_length)));
                        // upper_arm_transform = upper_arm_transform.times(Mat4.translation([-1*i,-1,0])); //moves by .5, 2

                        this.shapes.box.draw(graphics_state, upper_arm_transform, this.fire);
                        upper_arm_transform = orig;
                    }
                }
                draw_skateboard(graphics_state, board_transform, scene) {
                    // board_transform = board_transform.times(Mat4.translation(Vec.of(this.leg_width,-5*this.leg_height/4,0)));

                    board_transform = board_transform.times(Mat4.translation(Vec.of(0, -this.body_height - 4.5*this.leg_height - 1.75*this.shoe_height, 2*this.body_length)));
                    this.shapes.box.draw(graphics_state, board_transform.times(Mat4.scale(Vec.of(this.board_width,this.board_height,this.board_length))), this.fire);

                    let wheel_transform = board_transform;
                    var orig = wheel_transform;
                    for (let i of [-1, 1]){
                        for (let j of [-1, 1]) {
                            wheel_transform = wheel_transform.times(Mat4.translation([this.board_width*j, -2*this.shoe_height, this.board_length*i]));
                            this.shapes.ball.draw(graphics_state, wheel_transform, this.blueGlass);
                            wheel_transform = orig;
                        }
                    }
                }
                draw_legs(graphics_state, leg_transform, scene) {
                    let hinge_width = 0;
                    let hinge_height = this.leg_height;
                    let hinge_length = this.leg_length;

                    var upper_leg_transform = leg_transform;
                    var orig = upper_leg_transform;
                    for (let i of [-1,1]) {
                        //correct location
                        if (scene <= 1){
                            upper_leg_transform = upper_leg_transform.times(Mat4.translation([-this.body_length/2*i,-this.body_height-this.leg_height,0])); //transfer to hinge
                        }
                        else{
                            upper_leg_transform = upper_leg_transform.times(Mat4.translation([-this.body_length*i,-this.body_height-this.leg_height,0])); //transfer to hinge
                        }

                        //hinge location
                        upper_leg_transform = upper_leg_transform.times(Mat4.translation(Vec.of(hinge_width, hinge_height, hinge_length)));
                        upper_leg_transform = upper_leg_transform.times(Mat4.rotation(-1 + Math.PI/24*(Math.sin(this.globals.graphics_state.animation_time/100)), Vec.of(1,0,0)));
                        upper_leg_transform = upper_leg_transform.times(Mat4.translation(Vec.of(-hinge_width, -hinge_height, -hinge_length)));
                        //scale
                        this.shapes.box.draw(graphics_state, upper_leg_transform.times(Mat4.scale(Vec.of(this.leg_width,this.leg_height,this.leg_length))), this.fire);

                        let bottom_leg_transform = upper_leg_transform;
                        //correct position
                        bottom_leg_transform = bottom_leg_transform.times(Mat4.translation(Vec.of(0,-2*this.leg_height,0)));
                        //hinge
                        bottom_leg_transform = bottom_leg_transform.times(Mat4.translation(Vec.of(hinge_width, hinge_height, -hinge_length)));
                        bottom_leg_transform = bottom_leg_transform.times(Mat4.rotation(-(-1 + Math.PI/24*(Math.sin(this.globals.graphics_state.animation_time/100))), Vec.of(1,0,0)));
                        bottom_leg_transform = bottom_leg_transform.times(Mat4.translation(Vec.of(-hinge_width, -(hinge_height), hinge_length)));
                        //scale
                        this.shapes.box.draw(graphics_state, bottom_leg_transform.times(Mat4.scale(Vec.of(this.leg_width,this.leg_height,this.leg_length))), this.fire);

                        let foot_transform = bottom_leg_transform;
                        foot_transform = foot_transform.times(Mat4.translation(Vec.of(0,-this.leg_height-1, 0)));
                        this.shapes.ball.draw(graphics_state, foot_transform, this.fire);

                        let shoe_transform = orig;
                        if (scene <= 1) {
                            shoe_transform = shoe_transform.times(Mat4.translation(Vec.of(i, -this.body_height - 4.5*this.leg_height, 2*this.body_length)));
                        }
                        else {
                            shoe_transform = shoe_transform.times(Mat4.translation(Vec.of(this.body_width*2*i, -this.body_height - 4.5*this.leg_height, 2*this.body_length)));
                        }
                        this.shapes.box.draw(graphics_state, shoe_transform.times(Mat4.scale(Vec.of(this.shoe_width,this.shoe_height,this.shoe_length))), this.stars);
                        upper_leg_transform = orig;
                    }
                }
                draw_cliff(graphics_state, cliff_transform, scene) {
                    cliff_transform = cliff_transform.times(Mat4.translation(Vec.of(0, -this.body_height - 4.5*this.leg_height - 2*this.shoe_height -2.5 - this.cliff_height, 2*this.body_length)));
                    this.shapes.box.draw(graphics_state, cliff_transform.times(Mat4.scale(Vec.of(this.cliff_width, this.cliff_height, this.cliff_length))), this.greenGrass);
                }
                draw_branch(graphics_state, branch_transform, scene) {
                    var branchOffset_width = this.cliff_width+7*this.butterfly_body_width;
                    var branchOffset_height = -1*this.cliff_height;
                    var branchOffset_length = 3;
                    var small_branch_width = .5;
                    var small_branch_height = .5;
                    var small_branch_length = 2;

                    var small_branch = branch_transform;

                    branch_transform = branch_transform.times(Mat4.translation([branchOffset_width, branchOffset_height, branchOffset_length]));
                    this.shapes.box.draw(graphics_state, branch_transform.times(Mat4.scale(Vec.of(7,1,1))), this.brown);
                    branch_transform = branch_transform.times(Mat4.translation([7,0,0]));
                    this.shapes.ball.draw(graphics_state, branch_transform.times(Mat4.scale(Vec.of(2,2,2))), this.brown);

                    var small_branch = branch_transform.times(Mat4.translation([2,0,0]));

                    var orig = small_branch;
                    for (let i of [-1,1]) {
                        small_branch = small_branch.times(Mat4.rotation(-1*Math.PI/4, Vec.of(1, 0, 0)));
                        small_branch = small_branch.times(Mat4.rotation(i*Math.PI/4, Vec.of(0, 1, 0)));
                        small_branch = small_branch.times(Mat4.rotation(i*Math.PI/4, Vec.of(0, 1, 0)));
                        small_branch = small_branch.times(Mat4.translation(Vec.of(small_branch_width,0,0)));

                        this.shapes.box.draw(graphics_state, small_branch.times(Mat4.scale([small_branch_width, small_branch_height, small_branch_length])), this.green);
                    }
                }
                draw_portal(graphics_state, portal_transform, scene) {
                    if (scene == 5){
                        portal_transform = portal_transform.times(Mat4.rotation(Math.PI/4, Vec.of(0,-1,0)));
                        this.shapes.capped.draw(graphics_state, portal_transform.times(Mat4.scale([this.portal_width, this.portal_height, this.portal_length])), this.fire);
                    }
                    else {
                        let cave_width = 300;
                        let cave_height = 300;
                        let cave_length = 0;
                        portal_transform = portal_transform.times(Mat4.rotation(Math.PI/4, Vec.of(0,1,0)));
                        this.shapes.capped.draw(graphics_state, portal_transform.times(Mat4.scale([2*this.portal_width, this.portal_height, 2*this.portal_length])), this.fire);

                        var cave_transform = Mat4.identity();
                        cave_transform = cave_transform.times(Mat4.translation([3*this.cliff_width+8*this.butterfly_body_width, -1.55*this.cliff_height, -50]))
                        this.shapes.strip.draw(graphics_state, cave_transform.times(Mat4.scale([cave_width, cave_height, cave_length])), this.rgb);
                        var gem_transform = cave_transform;

                        var orig = gem_transform;
                        for (let i of [-3.5, -1.5, 1.5, 4]){
                            for (let j of [-5, -2, 1.5, 2, 3.5]) {
                                //UNCOMMENT
                                // var numColor = Math.floor((Math.random() * 6));
                                gem_transform = gem_transform.times(Mat4.translation([cave_width/i, cave_height/j, cave_length]));
                                // this.shapes.gem.draw(graphics_state, gem_transform.times(Mat4.scale([10,10,10])), numToColor[numColor]);
                                this.shapes.myshape.draw(graphics_state, gem_transform.times(Mat4.scale([10,10,10])), this.red);
                                gem_transform = orig;
                            }
                        }

                    }
                }
                draw_genie(graphics_state, genie_transform, scene){
                    let genie_parts_offset = -30;
                    genie_transform = genie_transform.times(Mat4.translation([0, Math.sin(this.t),0]))
                    this.shapes.box.draw(graphics_state, genie_transform.times(Mat4.scale([10,10,10])), this.red);
                    genie_transform = genie_transform.times(Mat4.translation([0,genie_parts_offset,0]));
                    this.shapes.septagon.draw(graphics_state, genie_transform.times(Mat4.scale([20,20,20])), this.red);
                    genie_transform = genie_transform.times(Mat4.translation([0,genie_parts_offset,0]));
                    genie_transform = genie_transform.times(Mat4.rotation(Math.PI/4, Vec.of(0,1,0)));
                    this.shapes.swept_curve.draw(graphics_state, genie_transform.times(Mat4.scale([10,10,10])), this.red);
                }
                scene1(graphics_state, body_transform) {
                    //camera, looking at, up
                    // graphics_state.camera_transform = Mat4.look_at( Vec.of( -20,0, 80), Vec.of( 0,0,0 ), Vec.of( 0,1,0 ) );
                    this.draw_cliff(graphics_state, this.cliff_transform, 1);

                    body_transform = body_transform.times(Mat4.translation([4*this.t, 0, 0]));
                    this.shapes.box.draw( graphics_state, body_transform.times(Mat4.scale(Vec.of(this.body_length,this.body_height,this.body_width))), this.stars );
                    this.draw_head(graphics_state, body_transform, 1);
                    this.draw_arms(graphics_state, body_transform, 1);
                    this.draw_legs(graphics_state, body_transform, 1);

                    var board_transform = Mat4.identity();
                    board_transform = board_transform.times(Mat4.translation([4*this.t, 0, 0]));
                    this.draw_skateboard(graphics_state, board_transform, 1);

                    this.body_transform_next = body_transform;
                    this.board_transform_next = board_transform;
                }
                scene2(graphics_state, body_transform) {
                    this.t = this.t - this.time_offset;
                    body_transform = this.body_transform_next;
                    var board_transform = this.board_transform_next;

                    this.draw_cliff(graphics_state, this.cliff_transform, 2);

                    body_transform = body_transform.times(Mat4.translation([0, -5*(this.t), 0]));
                    var angle = this.t/5;
                    if (angle < Math.PI/8) {
                        body_transform = body_transform.times(Mat4.rotation(angle, Vec.of(0, 1, 1)));
                    }
                    else{
                        body_transform = body_transform.times(Mat4.rotation(Math.PI/8, Vec.of(0, 1, 1)));
                    }

                    this.shapes.box.draw( graphics_state, body_transform.times(Mat4.scale(Vec.of(this.body_length,this.body_height,this.body_width))), this.stars );
                    this.draw_head(graphics_state, body_transform, 2);
                    this.draw_arms(graphics_state, body_transform, 2);
                    this.draw_legs(graphics_state, body_transform, 2);

                    board_transform = board_transform.times(Mat4.translation([0, -4*(this.t), 0]));
                    angle = this.t/5;
                    if (angle < Math.PI/12) {
                        board_transform = board_transform.times(Mat4.rotation(angle, Vec.of(0, -1, -1)));
                    }
                    else{
                        board_transform = board_transform.times(Mat4.rotation(Math.PI/12, Vec.of(0, -1, -1)));
                    }
                    this.draw_skateboard(graphics_state, board_transform, 2);

                    var branch_transform = this.branch_transform;
                    this.draw_branch(graphics_state, branch_transform, 2);

                    this.body_transform_curr = body_transform;
                    this.board_transform_curr = board_transform;
                    this.branch_transform_curr = branch_transform;
                }
                scene3(graphics_state, body_transform){
                    this.t = this.t - this.time_offset;
                    body_transform = this.body_transform_curr;
                    var board_transform = this.board_transform_curr;
                    var butterfly_transform = this.butterfly_transform_curr;
                    var branch_transform = this.branch_transform_curr;

                    this.draw_cliff(graphics_state, this.cliff_transform, 3);
                    body_transform = body_transform.times(Mat4.rotation(Math.PI/8, Vec.of(0, -1, -1)));
                    body_transform = body_transform.times(Mat4.translation([0, -5*(this.t), 0]));
                    body_transform = body_transform.times(Mat4.rotation(Math.PI/8, Vec.of(0, 1, 1)));

                    this.shapes.box.draw( graphics_state, body_transform.times(Mat4.scale(Vec.of(this.body_length,this.body_height,this.body_width))), this.stars );
                    this.draw_head(graphics_state, body_transform, 3);
                    this.draw_arms(graphics_state, body_transform, 3);
                    this.draw_legs(graphics_state, body_transform, 3);

                    //elastic jump
                    board_transform = board_transform.times(Mat4.translation([0, 10*Math.abs(Math.sin(this.t)), 0]))
                    this.draw_skateboard(graphics_state, board_transform);

                    this.draw_branch(graphics_state, branch_transform);

                    butterfly_transform = butterfly_transform.times(Mat4.translation([this.cliff_width+8*this.butterfly_body_width, -1.55*this.cliff_height, -10]))
                    this.draw_butterfly(graphics_state, butterfly_transform);

                    this.body_transform_next = body_transform;
                    this.board_transform_next = board_transform;
                    this.butterfly_transform_next = butterfly_transform;
                    this.branch_transform_next = branch_transform;
                }
                scene4(graphics_state, body_transform){
                    this.t = this.t - this.time_offset;
                    body_transform = this.body_transform_next;
                    var board_transform = this.board_transform_next;
                    var butterfly_transform = this.butterfly_transform_next;
                    var branch_transform = this.branch_transform_next;

                    this.draw_cliff(graphics_state, this.cliff_transform);

                    body_transform = body_transform.times(Mat4.rotation(Math.PI/8, Vec.of(0, -1, -1)));
                    body_transform = body_transform.times(Mat4.rotation(Math.PI/2, Vec.of(0, 1, 0)));

                    this.shapes.box.draw( graphics_state, body_transform.times(Mat4.scale(Vec.of(this.body_length,this.body_height,this.body_width))), this.stars );
                    this.draw_head(graphics_state, body_transform, 4);
                    this.draw_arms(graphics_state, body_transform, 4);
                    this.draw_legs(graphics_state, body_transform, 4);

                    //elastic jump
                    board_transform = board_transform.times(Mat4.translation([0, 10*Math.abs(Math.sin(this.t)), 0]))
                    this.draw_skateboard(graphics_state, board_transform, 4);

                    this.draw_branch(graphics_state, branch_transform, 4);

                    butterfly_transform = this.butterfly_transform;
                    butterfly_transform = butterfly_transform.times(Mat4.translation([this.cliff_width+8*this.butterfly_body_width, -1.55*this.cliff_height, -10]))
                    this.draw_butterfly(graphics_state, butterfly_transform, 4);

                    this.body_transform_curr = body_transform;
                    this.board_transform_curr = board_transform;
                    this.butterfly_transform_curr = butterfly_transform;
                    this.branch_transform_curr = branch_transform;
                }
                scene5(graphics_state, body_transform){
                    this.t = this.t - this.time_offset;
                    body_transform = this.body_transform_curr;
                    var board_transform = this.board_transform_curr;
                    var butterfly_transform = this.butterfly_transform_curr;
                    var branch_transform = this.branch_transform_curr;
                    var portal_transform = this.portal_transform_curr;

                    this.draw_cliff(graphics_state, this.cliff_transform, 5);

                    body_transform = body_transform.times(Mat4.translation([0, 3*Math.sin(3*this.t), 10*this.t]));
                    this.shapes.box.draw( graphics_state, body_transform.times(Mat4.scale(Vec.of(this.body_length,this.body_height,this.body_width))), this.stars );
                    this.draw_head(graphics_state, body_transform, 5);
                    this.draw_arms(graphics_state, body_transform, 5);
                    this.draw_legs(graphics_state, body_transform, 5);

                    //elastic jump
                    board_transform = board_transform.times(Mat4.translation([0, 10*Math.abs(Math.sin(this.t)), 0]))
                    this.draw_skateboard(graphics_state, board_transform, 5);

                    branch_transform = this.branch_transform;
                    this.draw_branch(graphics_state, branch_transform, 5);

                    butterfly_transform = butterfly_transform.times(Mat4.translation([10*this.t, 3*Math.sin(3*this.t), 0]));
                    this.draw_butterfly(graphics_state, butterfly_transform, 5);

                    portal_transform = portal_transform.times(Mat4.translation([3*this.cliff_width+8*this.butterfly_body_width, -1.55*this.cliff_height, -10]))
                    this.draw_portal(graphics_state, portal_transform, 5);

                    this.body_transform_next = body_transform;
                    this.board_transform_next = board_transform;
                    this.butterfly_transform_next = butterfly_transform;
                    this.branch_transform_next = branch_transform;
                    this.portal_transform_next = portal_transform;
                }
                scene6(graphics_state, body_transform) {
                    this.t = this.t - this.time_offset;
                    body_transform = this.body_transform_next;
                    var butterfly_transform = this.butterfly_transform_next;
                    var portal_transform = this.portal_transform_next;
                    var genie_transform = this.genie_transform_next;

                    body_transform = body_transform.times(Mat4.translation([0, 3*Math.sin(3*this.t), 10*this.t]));
                    this.shapes.box.draw( graphics_state, body_transform.times(Mat4.scale(Vec.of(this.body_length,this.body_height,this.body_width))), this.stars );
                    this.draw_head(graphics_state, body_transform, 6);
                    this.draw_arms(graphics_state, body_transform, 6);
                    this.draw_legs(graphics_state, body_transform, 6);

                    butterfly_transform = butterfly_transform.times(Mat4.translation([10*this.t, 3*Math.sin(3*this.t), 0]));
                    this.draw_butterfly(graphics_state, butterfly_transform, 6);

                    this.draw_portal(graphics_state, portal_transform, 6);

                    genie_transform = genie_transform.times(Mat4.translation([6*this.cliff_width+8*this.butterfly_body_width, -1.55*this.cliff_height, 0]))
                    // genie_transform = genie_transform.times(Mat4.rotation(Math.PI/2, Vec.of(1,0,0)));
                    this.draw_genie(graphics_state, genie_transform, 6);

                    this.body_transform_curr = body_transform;
                    this.butterfly_transform_curr = butterfly_transform;
                    this.portal_transform_curr = portal_transform;
                    this.genie_transform_curr = genie_transform;
                }

                display( graphics_state )
                {
                    this.t = graphics_state.animation_time/1000;
                    var storedTime = this.globals.graphics_state.animation_time;

                    var model_transform = Mat4.identity();             // We begin with a brand new model_transform every frame.

                    //   *** Lights: *** Values of vector or point lights over time.  Two different lights *per shape* supported by Phong_Shader; more requires changing a number in the vertex
                    graphics_state.lights = [ new Light( Vec.of(  30,  30,  34, 1 ), Color.of( 0, .4, 0, 1 ), 100000 ),      // shader.  Arguments to construct a Light(): Light source position
                        new Light( Vec.of( -10, -20, -14, 0 ), Color.of( 1, 1, .3, 1 ), 100    ) ];    // or vector (homogeneous coordinates), color, and size.

                        var body_transform = model_transform;

                        let timeScene1 = 0;
                        let timeScene2 = 12;
                        let timeScene3 = 20;
                        let timeScene4 = 26.6;
                        let timeScene5 = 28;
                        let timeScene6 = 37;

                        if (this.t > 0 && this.t <= timeScene2) {
                            console.log(1);
                            //skateboarding
                            this.scene1(graphics_state, body_transform);
                        }
                        else if (this.t > timeScene2 && this.t <= timeScene3) {
                            console.log(2);
                            //animate curve of fall, fall, branch appears
                            this.time_offset = timeScene2;
                            this.scene2(graphics_state, body_transform);
                        }
                        else if (this.t > timeScene3 && this.t <= timeScene4) {
                            console.log(3);
                            //skateboard bounces on branch, butterfly appears
                            this.time_offset =  timeScene3;
                            this.scene3(graphics_state, body_transform);
                        }
                        else if (this.t > timeScene4 && this.t <= timeScene5) {
                            console.log(4);
                            //person sits on butterfly and butterfly moves?
                            this.time_offset = timeScene4;
                            this.scene4(graphics_state, body_transform);
                        }
                        else if (this.t > timeScene5 && this.t <= timeScene6) {
                            console.log(5);
                            //person and butterfly move and create portal
                            this.time_offset = timeScene5;
                            this.scene5(graphics_state, body_transform);
                        }
                        else if (this.t > timeScene6) {
                            console.log(6);
                            //portal changes to cave and genie appears
                            this.time_offset = timeScene6;
                            this.scene6(graphics_state, body_transform);
                        }


                        //   model_transform.post_multiply( Mat4.translation([ 0, -2, 0 ]) );
                        //   this.shapes.strip          .draw( graphics_state, model_transform, this.greyPlastic   );
                        //
                        //   var t = graphics_state.animation_time/1000,   tilt_spin   = Mat4.rotation( 12*t, Vec.of(          .1,          .8,             .1 ) ),
                        //                                                 funny_orbit = Mat4.rotation(  2*t, Vec.of( Math.cos(t), Math.sin(t), .7*Math.cos(t) ) );
                        //
                        //   // Many shapes can share influence of the same pair of lights, but they don't have to.  All the following shapes will use these lights instead of the above ones.
                        //   graphics_state.lights = [ new Light( tilt_spin.times( Vec.of(  30,  30,  34, 1 ) ), Color.of( 0, .4, 0, 1 ), 100000               ),
                        //                             new Light( tilt_spin.times( Vec.of( -10, -20, -14, 0 ) ), Color.of( 1, 1, .3, 1 ), 100*Math.cos( t/10 ) ) ];
                        //
                        //   model_transform.post_multiply( Mat4.translation([ 0, -2, 0 ]) );
                        //   this.shapes.tetrahedron    .draw( graphics_state, model_transform.times( funny_orbit ), this.purplePlastic );
                        //
                        //   model_transform.post_multiply( Mat4.translation([ 0, -2, 0 ]) );
                        //   this.shapes.bad_tetrahedron.draw( graphics_state, model_transform.times( funny_orbit ), this.greyPlastic   );
                        //
                        //   model_transform.post_multiply( Mat4.translation([ 0, -2, 0 ]) );
                        //   this.shapes.windmill       .draw( graphics_state, model_transform.times( tilt_spin ),   this.purplePlastic );
                        //   model_transform.post_multiply( Mat4.translation([ 0, -2, 0 ]) );
                        //   this.shapes.windmill       .draw( graphics_state, model_transform,                      this.fire          );
                        //   model_transform.post_multiply( Mat4.translation([ 0, -2, 0 ]) );
                        //   this.shapes.windmill       .draw( graphics_state, model_transform,                      this.blueGlass     );
                    }
                }
                </script>
                <style>
                table { border-collapse: collapse; display:block; overflow-x: auto; }
                table, th, td { border: 2px solid black; vertical-align: top; white-space: nowrap }
                th, td { overflow: hidden;  }
                button { position: relative; background-color: #4C9F50; color: white; padding: 6px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); transition: background-color .3s, transform .3s }
                button:hover, button:focus { transform: scale(1.2); color:gold }
                .dropdown { display:inline-block }
                .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; min-width: 100px; overflow: auto; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2) }
                .dropdown-content a { color: black; padding: 4px 4px; display: block }
                .dropdown a:hover { background-color: #f1f1f1 }
                .show { display:inline-block }
                </style>
            </head><body>
                <div id="explanation_section"></div>
                <div id="canvases"></div>
                <table id="control_buttons" class="dropdown" style="display:block; width: 70%;  border: 0px; margin: 0 0 50px 0"><tr></tr></table>
                <div id="code_panel" style="font-family: monospace; white-space: pre; margin: 50px 0" >
                    <div id="code_display"  data-displayed="" ></div>
                    <button id="edit_button" style="display:none">Start editing</button>
                    <table id="class_list" class="dropdown" style="display:block; border: 0px; border-spacing: 10px " >
                        <tr><td colspan="2">Click below to navigate through all classes that are defined. <br>&nbsp;<br>Main demo: <span name="main_demo_link"></span></td></tr>
                        <tr style="text-align:center"><td>tinywebgl-ucla.js</td><td>dependencies.js</td></tr><tr></tr></table>
                    </div>
                    <form name="new_demo_source_code" style="display:none">
                        <p style="margin: 50px 0"><i><b>What can I put here?</b></i>  A JavaScript class, with any valid JavaScript inside.  Your code can use classes from this demo, or from ANY demo on the
                            encyclopedia of code --  the dependencies will automatically be pulled in to run your demo!<br></p>
                            <textarea rows="30" cols="140" name="new_demo_code"></textarea><br>
                            <div id="submit_result" style="margin: 10px 0"></div>
                            <button type="submit" style="margin: 0px 50px 0px 0px">Save as new webpage</button>
                            <input type="text" name="author"   placeholder="Author name">
                            <input type="text" name="password" placeholder="Password" style="display:none">
                            <span id="overwrite_panel" style="display:none"><label>Overwrite?<input type="checkbox" name="overwrite" autocomplete="off"></label></span>
                            <span id="beginner_panel"><label>Beginner Mode<input type="checkbox" checked onchange="document.querySelector('#expert_panel').style.display='block'; beginner_panel.style.display='none'"></label></span>
                            <div id="expert_panel" style="display:none;"><label><input type="checkbox" name="finished" autocomplete="off">
                                Optional:  This demo is finished; consider it for public listing on the main page.
                                I believe that this demo is the one true way to minimalistically do what its name says.
                                The code's readability and structure are so good as to maximize how easy it is to memorize it.
                            </label></div>
                        </form>
                    </body></html>
